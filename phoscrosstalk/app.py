import os
import sys
import numpy as np
import pandas as pd
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

import networkx as nx
import gravis as gv

sys.path.append(os.getcwd())

from phoscrosstalk.config import ModelDims
from phoscrosstalk.simulation import simulate_p_scipy, build_full_A0
from phoscrosstalk.core_mechanisms import decode_theta

# --- Page Config ---
st.set_page_config(
    page_title="PhosCrosstalk Explorer",
    page_icon="ðŸ§¬",
    layout="wide",
    initial_sidebar_state="expanded"
)


# --- Helper: Data Loading ---
@st.cache_data
def load_snapshot_data(results_dir):
    """
    Load simulation state, matrices, and metadata from the optimization output.

    This function reconstructs the full environment required to simulate the model
    by reading the `preopt_snapshot` directory (TSV/TXT files) and the `fitted_params.npz`
    file generated by the analysis pipeline.

    Args:
        results_dir (str): Path to the root directory containing the optimization results
                           (must contain 'preopt_snapshot/' and 'fitted_params.npz').

    Returns:
        dict or None: A dictionary containing:
            - 'theta' (np.ndarray): Optimized parameter vector.
            - 't_orig' (np.ndarray): Original time points.
            - 'sites', 'proteins', 'kinases' (list): ID lists.
            - 'P_scaled', 'A_scaled', 'Y_orig' (np.ndarray): Data matrices.
            - 'Cg', 'Cl', 'K_site_kin', 'R', 'L_alpha' (np.ndarray): Topology/Interaction matrices.
            - 'meta' (dict): Configuration metadata (mechanism, scaling modes).
            - 'prot_idx_for_A' (np.ndarray): Indices mapping abundance data to proteins.
            Returns None if the necessary files are missing.
    """
    snap_dir = os.path.join(results_dir, "preopt_snapshot")
    fit_path = os.path.join(results_dir, "fitted_params.npz")

    if not os.path.exists(snap_dir) or not os.path.exists(fit_path):
        return None

    # Load Fitted Params
    fit_data = np.load(fit_path, allow_pickle=True)
    theta = fit_data["theta"]

    # Load Metadata
    def load_vec(name, dtype=float):
        return np.loadtxt(os.path.join(snap_dir, f"{name}.tsv"), delimiter="\t", dtype=dtype)

    def load_mat(name, dtype=float):
        # Handle empty matrices
        try:
            return np.loadtxt(os.path.join(snap_dir, f"{name}.tsv"), delimiter="\t", dtype=dtype, ndmin=2)
        except:
            return np.array([])

    def load_txt_list(name):
        with open(os.path.join(snap_dir, f"{name}.txt"), "r") as f:
            return [line.strip() for line in f if line.strip()]

    # Load Data
    data = {
        "theta": theta,
        "t_orig": load_vec("t"),
        "sites": load_txt_list("sites"),
        "proteins": load_txt_list("proteins"),
        "kinases": load_txt_list("kinases"),
        "positions": load_vec("positions"),
        "P_scaled": load_mat("P_scaled"),
        "A_scaled": load_mat("A_scaled"),
        "Y_orig": load_mat("Y"),  # Raw FC data
        "Cg": load_mat("Cg"),
        "Cl": load_mat("Cl"),
        "K_site_kin": load_mat("K_site_kin"),
        "R": load_mat("R"),
        "L_alpha": load_mat("L_alpha"),
        "site_prot_idx": load_vec("site_prot_idx", int).flatten(),
        "kin_to_prot_idx": load_vec("kin_to_prot_idx", int).flatten(),
        "receptor_mask_prot": load_vec("receptor_mask_prot", int).flatten(),
        "receptor_mask_kin": load_vec("receptor_mask_kin", int).flatten(),
    }

    # Load Metadata for Mechanism and Config
    meta_path = os.path.join(snap_dir, "meta.txt")
    meta_dict = {}
    with open(meta_path, "r") as f:
        for line in f:
            if "\t" in line:
                k, v = line.strip().split("\t", 1)
                meta_dict[k] = v
    data["meta"] = meta_dict

    # Reconstruct Prot Index for A (Requires finding mapping again or saving it)
    # In analysis.py we saved A_proteins but not the index map explicitly in simple form.
    # However, A_scaled rows correspond to the proteins in A_proteins.txt.
    # We need to map these back to the main protein index.
    if os.path.exists(os.path.join(snap_dir, "A_proteins.txt")):
        a_prots = load_txt_list("A_proteins")
        prot_map = {p: i for i, p in enumerate(data["proteins"])}
        prot_idx_for_A = np.array([prot_map[p] for p in a_prots if p in prot_map], dtype=int)
        data["prot_idx_for_A"] = prot_idx_for_A
    else:
        data["prot_idx_for_A"] = np.array([], dtype=int)

    return data


@st.cache_data
def run_fine_simulation(data, t_max, num_points=200):
    """
    Execute a high-resolution simulation of the protein signaling network.

    This function sets the global model dimensions, constructs the initial condition
    matrix (A0) handling time-dimension mismatches, and solves the ODE system
    using the SciPy integrator.

    Args:
        data (dict): The data dictionary loaded via `load_snapshot_data`.
        t_max (float): The end time for the simulation (in minutes).
        num_points (int, optional): Number of time steps for the fine grid. Defaults to 200.

    Returns:
        tuple:
            - t_fine (np.ndarray): The generated time vector.
            - P_sim (np.ndarray): Simulated phosphosite trajectories (N x Time).
            - A_sim (np.ndarray): Simulated protein abundance trajectories (K x Time).
    """
    # 1. Set Global Dims
    K = len(data["proteins"])
    M = len(data["kinases"])
    N = len(data["sites"])
    ModelDims.set_dims(K, M, N)

    # 2. Time Grid
    t_fine = np.linspace(0, t_max, num_points)

    # 3. Build A0 (Corrected for Fine Resolution)
    # We cannot use build_full_A0 directly because data['A_scaled'] shape (14,)
    # doesn't match t_fine shape (300,).
    # Since simulate_p_scipy ONLY uses column 0 for initial conditions,
    # we manually build a compatible matrix.

    A0_full = np.zeros((K, len(t_fine)), dtype=float)

    if data["A_scaled"].size > 0:
        for k, p_idx in enumerate(data["prot_idx_for_A"]):
            # Only set the initial condition (t=0)
            # We assume the rest evolves via ODEs
            if data["A_scaled"].shape[1] > 0:
                A0_full[p_idx, 0] = data["A_scaled"][k, 0]

    # 4. Simulate
    mechanism = data["meta"].get("mechanism", "dist")

    P_sim, A_sim, S_sim, Kdyn_sim = simulate_p_scipy(
        t_fine,
        data["P_scaled"],  # Used for Init Cond (P)
        A0_full,  # Used for Init Cond (A)
        data["theta"],
        data["Cg"],
        data["Cl"],
        data["site_prot_idx"],
        data["K_site_kin"],
        data["R"],
        data["L_alpha"],
        data["kin_to_prot_idx"],
        data["receptor_mask_prot"],
        data["receptor_mask_kin"],
        mechanism,
        full_output=True
    )

    return t_fine, P_sim, A_sim, S_sim, Kdyn_sim


def calculate_scalers(Y_orig):
    """
    Compute normalization scalers to map between [0-1] model space and Fold Change.

    Calculates the baseline (minimum) and range (max - min) for each row in the
    original dataset. Used to rescale model outputs back to experimental units
    for visualization.

    Args:
        Y_orig (np.ndarray): The original experimental data matrix (e.g., Fold Change).

    Returns:
        tuple:
            - baselines (np.ndarray): Array of minimum values per row.
            - ranges (np.ndarray): Array of ranges (max-min) per row.
    """
    baselines = np.min(Y_orig, axis=1)
    ranges = np.max(Y_orig, axis=1) - np.min(Y_orig, axis=1)
    ranges[ranges < 1e-6] = 1.0
    return baselines, ranges


# --- Sidebar ---
st.sidebar.title("PhosCrosstalk Explorer")
results_dir = st.sidebar.text_input("Results Directory Path", value="network_fit")

if not os.path.exists(results_dir):
    st.error(f"Directory '{results_dir}' not found.")
    st.stop()

data = load_snapshot_data(results_dir)

if data is None:
    st.error("Could not load 'fitted_params.npz' or 'preopt_snapshot'. Ensure analysis was run.")
    st.stop()

st.sidebar.success("Data Loaded Successfully")

# --- Global Simulation ---
t_max = data["t_orig"][-1]
t_fine, P_sim_fine, A_sim_fine, S_sim_fine, Kdyn_sim_fine = run_fine_simulation(data, t_max, num_points=10000)

# Rescaling logic
baselines, amplitudes = calculate_scalers(data["Y_orig"])

# --- Tabs ---
tab1, tab2, tab3, tab4, tab5, tab6, tab7, tab8 = st.tabs(
    ["Trajectories", "Goodness of Fit", "Parameters", "Network Map",
     "Steady State", "Knockout Simulator", "Network Animation", "Sensitivity Analysis"]
)

# ==========================================
# TAB 1: Trajectories
# ==========================================
with tab1:
    col1, col2 = st.columns([1, 3])

    with col1:
        st.subheader("Select Target")
        selected_prot = st.selectbox("Select Protein", data["proteins"])

        # Identify sites for this protein
        prot_idx = data["proteins"].index(selected_prot)
        site_indices = np.where(data["site_prot_idx"] == prot_idx)[0]

        # Scaling Toggle
        # Added "Internal States" mode
        view_mode = st.radio("View Mode", ["Fold Change (Original)", "Scaled [0-1]", "Internal States (S, Kdyn)"])
        is_fc = view_mode == "Fold Change (Original)"
        is_internal = view_mode == "Internal States (S, Kdyn)"

    with col2:
        if is_internal:
            # --- INTERNAL STATES VIEW ---
            # Panel 1: Protein Active Fraction (S)
            # Panel 2: Upstream Kinase Activity (Kdyn) for kinases acting on this protein
            fig = make_subplots(rows=1, cols=2,
                                subplot_titles=(f"{selected_prot} Active Fraction (S)",
                                                f"Upstream Kinase Activity (Kdyn)"))

            # 1. S_sim trace
            fig.add_trace(
                go.Scatter(x=t_fine, y=S_sim_fine[prot_idx, :], mode='lines',
                           line=dict(width=3, color='purple'),
                           name=f"S ({selected_prot})"),
                row=1, col=1
            )

            # 2. Kdyn traces
            # Find kinases connected to this protein's sites
            relevant_kin_indices = set()
            for s_idx in site_indices:
                # Get kinases with non-zero weight for this site
                k_idxs = np.where(data["K_site_kin"][s_idx, :] > 0)[0]
                relevant_kin_indices.update(k_idxs)

            # Convert to list and sort
            relevant_kin_indices = sorted(list(relevant_kin_indices))

            if not relevant_kin_indices:
                fig.add_annotation(text="No direct upstream kinases mapped", xref="x2", yref="y2", showarrow=False)
            else:
                for k_idx in relevant_kin_indices[:10]:  # Limit to top 10 to prevent overcrowding
                    k_name = data["kinases"][k_idx]
                    fig.add_trace(
                        go.Scatter(x=t_fine, y=Kdyn_sim_fine[k_idx, :], mode='lines',
                                   name=f"Kdyn ({k_name})"),
                        row=1, col=2
                    )

            fig.update_layout(title_text=f"Internal States for {selected_prot}", height=500, template="plotly_white")
            fig.update_yaxes(title_text="Fraction [0-1]", range=[0, 1.05])
            fig.update_xaxes(title_text="Time (min)")

        else:
            # --- STANDARD VIEW (Abundance & Sites) ---
            fig = make_subplots(rows=1, cols=2,
                                subplot_titles=(f"{selected_prot} Abundance", f"{selected_prot} Phosphosites"))

            # Plot Protein Abundance
            if data["prot_idx_for_A"].size > 0:
                mask_a = np.where(data["prot_idx_for_A"] == prot_idx)[0]
                if len(mask_a) > 0:
                    a_idx_data = mask_a[0]
                    y_data = data["A_scaled"][a_idx_data]
                    # Note: plotting scaled A data. If FC requested, ideally map back,
                    # but usually A is normalized relative to t0 anyway.
                    fig.add_trace(
                        go.Scatter(x=data["t_orig"], y=y_data, mode='markers',
                                   marker=dict(symbol='square', size=10, color='gray'),
                                   name='Data (Abundance)'),
                        row=1, col=1
                    )

            # Model Line (Abundance)
            y_model = A_sim_fine[prot_idx, :]
            fig.add_trace(
                go.Scatter(x=t_fine, y=y_model, mode='lines',
                           line=dict(width=3, color='black'),
                           name='Model (Abundance)'),
                row=1, col=1
            )

            # Plot Phosphosites
            colors = px.colors.qualitative.Plotly
            if len(site_indices) == 0:
                fig.add_annotation(text="No mapped sites", xref="x2", yref="y2", showarrow=False)
            else:
                for i, s_idx in enumerate(site_indices):
                    site_name = data["sites"][s_idx]
                    short_name = site_name.split("_")[-1] if "_" in site_name else site_name
                    color = colors[i % len(colors)]

                    y_dat = data["P_scaled"][s_idx]
                    y_mod = P_sim_fine[s_idx]

                    if is_fc:
                        b, a = baselines[s_idx], amplitudes[s_idx]
                        y_dat = b + a * y_dat
                        y_mod = b + a * y_mod

                    fig.add_trace(
                        go.Scatter(x=data["t_orig"], y=y_dat, mode='markers',
                                   marker=dict(size=8, color=color, opacity=0.7),
                                   name=f"{short_name} (Data)"),
                        row=1, col=2
                    )
                    fig.add_trace(
                        go.Scatter(x=t_fine, y=y_mod, mode='lines',
                                   line=dict(width=2, color=color),
                                   name=f"{short_name} (Sim)"),
                        row=1, col=2
                    )

            fig.update_layout(height=500, template="plotly_white", hovermode="x unified",
                              title_text=f"Dynamics for {selected_prot}")
            fig.update_xaxes(title_text="Time (min)")
            if is_fc:
                fig.update_yaxes(title_text="Fold Change")
            else:
                fig.update_yaxes(title_text="Scaled Activity [0-1]")

        st.plotly_chart(fig, use_container_width=True)

# ==========================================
# TAB 2: Goodness of Fit
# ==========================================
with tab2:
    st.subheader("Observed vs Simulated")

    # We need to compute simulation at t_orig points
    # We can rely on simulate_p_scipy again for exact timepoints or interpolation.
    # Exact is better.
    ModelDims.set_dims(len(data["proteins"]), len(data["kinases"]), len(data["sites"]))
    A0_orig = build_full_A0(len(data["proteins"]), len(data["t_orig"]), data["A_scaled"], data["prot_idx_for_A"])

    P_sim_orig, _ = simulate_p_scipy(
        data["t_orig"], data["P_scaled"], A0_orig, data["theta"],
        data["Cg"], data["Cl"], data["site_prot_idx"],
        data["K_site_kin"], data["R"], data["L_alpha"], data["kin_to_prot_idx"],
        data["receptor_mask_prot"], data["receptor_mask_kin"],
        data["meta"].get("mechanism", "dist")
    )

    # Flatten
    y_true = []
    y_pred = []
    labels = []

    # Rescale if needed (Usually GoF is done on scaled data to be fair across dynamic ranges)
    # But user asked for FC. Let's do FC.
    for i in range(len(data["sites"])):
        b, a = baselines[i], amplitudes[i]

        real_dat = b + a * data["P_scaled"][i]
        real_sim = b + a * P_sim_orig[i]

        y_true.extend(real_dat)
        y_pred.extend(real_sim)
        labels.extend([data["sites"][i]] * len(real_dat))

    df_fit = pd.DataFrame({"Observed": y_true, "Simulated": y_pred, "Label": labels})

    # Metrics
    r2 = 1 - np.sum((df_fit["Observed"] - df_fit["Simulated"]) ** 2) / np.sum(
        (df_fit["Observed"] - df_fit["Observed"].mean()) ** 2)

    col_m1, col_m2 = st.columns(2)
    col_m1.metric("RÂ² (Global FC)", f"{r2:.4f}")
    col_m2.metric("Pearson Correlation", f"{df_fit['Observed'].corr(df_fit['Simulated']):.4f}")

    fig_fit = px.scatter(df_fit, x="Observed", y="Simulated", hover_data=["Label"], opacity=0.6)

    # Add identity line
    min_val = min(df_fit["Observed"].min(), df_fit["Simulated"].min())
    max_val = max(df_fit["Observed"].max(), df_fit["Simulated"].max())
    fig_fit.add_shape(type="line", x0=min_val, y0=min_val, x1=max_val, y1=max_val,
                      line=dict(color="Red", dash="dash"))

    fig_fit.update_layout(height=700, title="Goodness of Fit (Fold Change)")
    st.plotly_chart(fig_fit, use_container_width=True)

# ==========================================
# TAB 3: Parameters
# ==========================================
with tab3:
    st.subheader("Parameter Distributions")

    # Decode Theta
    ModelDims.set_dims(len(data["proteins"]), len(data["kinases"]), len(data["sites"]))
    params_decoded = decode_theta(data["theta"], ModelDims.K, ModelDims.M, ModelDims.N)

    # Unpack
    (k_act, k_deact, s_prod, d_deg, beta_g, beta_l, alpha,
     kK_act, kK_deact, k_off, gamma_S_p, gamma_A_S, gamma_A_p, gamma_K_net) = params_decoded

    # Dataframes
    df_prot_params = pd.DataFrame({
        "Protein": data["proteins"],
        "k_act": k_act, "k_deact": k_deact, "s_prod": s_prod, "d_deg": d_deg
    })

    df_kin_params = pd.DataFrame({
        "Kinase": data["kinases"],
        "alpha": alpha, "kK_act": kK_act, "kK_deact": kK_deact
    })

    df_site_params = pd.DataFrame({
        "Site": data["sites"],
        "k_off": k_off
    })

    p_col1, p_col2 = st.columns(2)

    with p_col1:
        st.markdown("#### Global Coupling")
        st.write(f"**Beta Global:** {beta_g:.4f}")
        st.write(f"**Beta Local:** {beta_l:.4f}")
        st.markdown("#### Gammas")
        st.write(f"S_p: {gamma_S_p:.3f}, A_S: {gamma_A_S:.3f}, A_p: {gamma_A_p:.3f}, K_net: {gamma_K_net:.3f}")

    with p_col2:
        param_type = st.selectbox("Visualize Parameter Set", ["Protein Rates", "Kinase Rates", "Site Phosphatase"])

        if param_type == "Protein Rates":
            fig_p = px.box(df_prot_params.melt(id_vars="Protein"), x="variable", y="value", points="all",
                           title="Protein Parameters")
            st.plotly_chart(fig_p)
            st.dataframe(df_prot_params, use_container_width=True)

        elif param_type == "Kinase Rates":
            fig_k = px.box(df_kin_params.melt(id_vars="Kinase"), x="variable", y="value", points="all",
                           title="Kinase Parameters")
            st.plotly_chart(fig_k)
            st.dataframe(df_kin_params, use_container_width=True)

        else:
            fig_s = px.histogram(df_site_params, x="k_off", nbins=30, title="Phosphatase Rate Distribution")
            st.plotly_chart(fig_s)
            st.dataframe(df_site_params, use_container_width=True)

# ==========================================
# TAB 4: Network Map
# ==========================================
with tab4:
    st.subheader("Interaction Matrices")

    mat_opt = st.selectbox("Select Matrix",
                           ["Kinase-Substrate (K_site_kin)", "Global Coupling (Cg)", "Local Coupling (Cl)",
                            "Kinase Network (L_alpha)"])

    if mat_opt == "Kinase-Substrate (K_site_kin)":
        # Sites x Kinases
        mat = data["K_site_kin"]
        x_lab = data["kinases"]
        y_lab = data["sites"]
        title = "Kinase (Col) -> Site (Row) Weights"
    elif mat_opt == "Global Coupling (Cg)":
        mat = data["Cg"]
        x_lab = data["sites"]
        y_lab = data["sites"]
        title = "Site <-> Site Crosstalk (Global)"
    elif mat_opt == "Local Coupling (Cl)":
        mat = data["Cl"]
        x_lab = data["sites"]
        y_lab = data["sites"]
        title = "Site <-> Site Crosstalk (Local)"
    else:
        mat = data["L_alpha"]
        x_lab = data["kinases"]
        y_lab = data["kinases"]
        title = "Kinase <-> Kinase Laplacian"

    # Don't plot huge matrices directly if too big
    if mat.shape[0] > 200:
        st.warning("Matrix is large. Showing top interactions only (Sum > 0).")
        # Filter logic could go here, but for now simple heatmap
        fig_mat = px.imshow(mat, title=title, color_continuous_scale="Viridis")
    else:
        fig_mat = px.imshow(mat, x=x_lab, y=y_lab, title=title, color_continuous_scale="Viridis")

    st.plotly_chart(fig_mat, use_container_width=True)

# ==========================================
# TAB 5: Steady State Analysis
# ==========================================
with tab5:
    st.subheader("Long-term Dynamics & Internal States")
    st.markdown("Simulate system evolution to steady state. Now includes **Internal States (S, Kdyn)**.")

    col_ss1, col_ss2 = st.columns([1, 3])

    with col_ss1:
        # Simulation Controls
        t_end_ss = st.slider("Simulation Duration (min)", min_value=1000, max_value=20000, value=5000, step=1000)
        ss_prot = st.selectbox("Select Protein to Inspect", data["proteins"], key="ss_prot")
        run_ss = st.button("Run Steady State Sim", type="primary")

    with col_ss2:
        if run_ss:
            with st.spinner(f"Simulating up to {t_end_ss} min..."):
                # 1. Setup Time
                t_log = np.logspace(np.log10(0.1), np.log10(t_end_ss), 300)
                t_ss = np.insert(t_log, 0, 0.0)

                # 2. Setup Dims
                K, M, N = len(data["proteins"]), len(data["kinases"]), len(data["sites"])
                ModelDims.set_dims(K, M, N)

                # 3. Build A0 (Manual Construction for Time Mismatch)
                A0_ss = np.zeros((K, len(t_ss)), dtype=float)
                if data["A_scaled"].size > 0:
                    for k, p_idx in enumerate(data["prot_idx_for_A"]):
                        if data["A_scaled"].shape[1] > 0:
                            A0_ss[p_idx, 0] = data["A_scaled"][k, 0]

                # 4. Simulate with full_output=True to get S and Kdyn
                P_ss, A_ss, S_ss, Kdyn_ss = simulate_p_scipy(
                    t_ss,
                    data["P_scaled"],  # Init Cond
                    A0_ss,  # Init Cond
                    data["theta"],
                    data["Cg"], data["Cl"], data["site_prot_idx"],
                    data["K_site_kin"], data["R"], data["L_alpha"], data["kin_to_prot_idx"],
                    data["receptor_mask_prot"], data["receptor_mask_kin"],
                    data["meta"].get("mechanism", "dist"),
                    full_output=True
                )

                # 5. Plotting: 2x2 Grid
                fig_ss = make_subplots(
                    rows=2, cols=2,
                    subplot_titles=(
                        f"Abundance (A)", f"Phosphosites (P)",
                        f"Active Fraction (S)", f"Upstream Kinase Activity (Kdyn)"
                    ),
                    vertical_spacing=0.15
                )

                # --- 1. Protein Abundance (Top Left) ---
                p_idx = data["proteins"].index(ss_prot)
                fig_ss.add_trace(
                    go.Scatter(x=t_ss, y=A_ss[p_idx], mode='lines', name="Abundance (A)",
                               line=dict(color='black', width=3)),
                    row=1, col=1
                )

                # --- 2. Phosphosites (Top Right) ---
                site_indices = np.where(data["site_prot_idx"] == p_idx)[0]
                colors = px.colors.qualitative.Plotly
                for i, s_idx in enumerate(site_indices):
                    site_name = data["sites"][s_idx].split("_")[-1]
                    c = colors[i % len(colors)]
                    # Rescale
                    y_scaled = baselines[s_idx] + amplitudes[s_idx] * P_ss[s_idx]
                    fig_ss.add_trace(
                        go.Scatter(x=t_ss, y=y_scaled, mode='lines', name=f"P_{site_name}", line=dict(color=c)),
                        row=1, col=2
                    )

                # --- 3. Protein Active Fraction (Bottom Left) ---
                fig_ss.add_trace(
                    go.Scatter(x=t_ss, y=S_ss[p_idx], mode='lines', name="Active (S)",
                               line=dict(color='purple', width=2)),
                    row=2, col=1
                )

                # --- 4. Upstream Kinase Activity (Bottom Right) ---
                # Identify upstream kinases
                relevant_kin_indices = set()
                for s_idx in site_indices:
                    k_idxs = np.where(data["K_site_kin"][s_idx, :] > 0)[0]
                    relevant_kin_indices.update(k_idxs)

                # Sort and limit to top 5
                relevant_kin_indices = sorted(list(relevant_kin_indices))

                for k_idx in relevant_kin_indices[:5]:
                    k_name = data["kinases"][k_idx]
                    fig_ss.add_trace(
                        go.Scatter(x=t_ss, y=Kdyn_ss[k_idx], mode='lines', name=f"Kdyn_{k_name}"),
                        row=2, col=2
                    )

                fig_ss.update_xaxes(type="log", title_text="Time (min) - Log Scale")
                fig_ss.update_yaxes(title_text="Level", row=1, col=1)
                fig_ss.update_yaxes(title_text="Fold Change", row=1, col=2)
                fig_ss.update_yaxes(title_text="Fraction [0-1]", row=2, col=1)
                fig_ss.update_yaxes(title_text="Fraction [0-1]", row=2, col=2)

                fig_ss.update_layout(height=700, template="plotly_white", title=f"Steady State Dynamics: {ss_prot}")
                st.plotly_chart(fig_ss, use_container_width=True)

                # Convergence Metric (using P)
                final_deriv = np.mean(np.abs(P_ss[:, -1] - P_ss[:, -10]))
                if final_deriv < 1e-4:
                    st.success(f"System reached steady state (Mean delta P: {final_deriv:.2e})")
                else:
                    st.warning(f"System may not have fully converged (Mean delta P: {final_deriv:.2e})")

# ==========================================
# TAB 6: Knockout Simulator
# ==========================================
with tab6:
    st.subheader("In-Silico Perturbation Analysis")
    st.markdown("Compare **Wild Type (WT)** vs **Knockout (KO)** dynamics for P, S, or Kdyn.")

    c1, c2, c3 = st.columns(3)

    with c1:
        ko_type = st.radio("Target Type", ["Kinase", "Protein", "Phosphosite"])

    with c2:
        if ko_type == "Kinase":
            target_list = data["kinases"]
        elif ko_type == "Protein":
            target_list = data["proteins"]
        else:
            target_list = data["sites"]

        target = st.selectbox("Select Target to Knockout", target_list)

    with c3:
        observe_prot = st.selectbox("Observe Impact On", data["proteins"], index=0)
        # Choose metric to inspect
        obs_metric = st.selectbox("Metric to Plot", ["Phosphosites (P)", "Protein Activity (S)"])
        t_ko = st.slider("Time (min)", 100, 1000, 240)

    run_ko = st.button("Simulate Knockout", type="primary")

    if run_ko:
        with st.spinner("Calculating Perturbations..."):
            # Setup
            K, M, N = len(data["proteins"]), len(data["kinases"]), len(data["sites"])
            ModelDims.set_dims(K, M, N)

            # Time vector
            t_eval = np.linspace(0, t_ko, 200)

            # A0 Construction
            A0_ko = np.zeros((K, len(t_eval)), dtype=float)
            if data["A_scaled"].size > 0:
                for k, p_idx in enumerate(data["prot_idx_for_A"]):
                    if data["A_scaled"].shape[1] > 0:
                        A0_ko[p_idx, 0] = data["A_scaled"][k, 0]

            # --- 1. Run Wild Type (Full Output) ---
            P_wt, A_wt, S_wt, Kdyn_wt = simulate_p_scipy(
                t_eval, data["P_scaled"], A0_ko, data["theta"],
                data["Cg"], data["Cl"], data["site_prot_idx"],
                data["K_site_kin"], data["R"], data["L_alpha"], data["kin_to_prot_idx"],
                data["receptor_mask_prot"], data["receptor_mask_kin"],
                data["meta"].get("mechanism", "dist"),
                full_output=True
            )

            # --- 2. Prepare KO Parameters ---
            theta_ko = data["theta"].copy()
            K_site_kin_ko = data["K_site_kin"]

            if ko_type == "Kinase":
                try:
                    k_idx = data["kinases"].index(target)
                    theta_ko[4 * K + 2 + k_idx] = -20.0
                except ValueError:
                    st.error("Kinase mapping error.");
                    st.stop()
            elif ko_type == "Protein":
                try:
                    p_idx = data["proteins"].index(target)
                    theta_ko[2 * K + p_idx] = -20.0
                except ValueError:
                    st.error("Protein mapping error.");
                    st.stop()
            elif ko_type == "Phosphosite":
                try:
                    s_idx = data["sites"].index(target)
                    K_site_kin_ko = data["K_site_kin"].copy()
                    K_site_kin_ko[s_idx, :] = 0.0
                except ValueError:
                    st.error("Site mapping error.");
                    st.stop()

            # --- 3. Run KO Simulation (Full Output) ---
            P_ko, A_ko, S_ko, Kdyn_ko = simulate_p_scipy(
                t_eval, data["P_scaled"], A0_ko, theta_ko,
                data["Cg"], data["Cl"], data["site_prot_idx"],
                K_site_kin_ko, data["R"], data["L_alpha"], data["kin_to_prot_idx"],
                data["receptor_mask_prot"], data["receptor_mask_kin"],
                data["meta"].get("mechanism", "dist"),
                full_output=True
            )

            # --- 4. Visualization ---
            obs_idx = data["proteins"].index(observe_prot)
            fig_ko = go.Figure()

            if obs_metric == "Protein Activity (S)":
                # Plot S comparison
                fig_ko.add_trace(
                    go.Scatter(x=t_eval, y=S_wt[obs_idx], mode='lines', name="WT (S)", line=dict(color='purple')))
                fig_ko.add_trace(go.Scatter(x=t_eval, y=S_ko[obs_idx], mode='lines', name="KO (S)",
                                            line=dict(color='purple', dash='dot')))
                yaxis_title = "Active Fraction (S)"
            else:
                # Plot Phosphosites (P) comparison
                site_indices = np.where(data["site_prot_idx"] == obs_idx)[0]
                colors = px.colors.qualitative.Bold
                yaxis_title = "Fold Change"

                for i, s_idx in enumerate(site_indices):
                    site_name = data["sites"][s_idx].split("_")[-1]
                    c = colors[i % len(colors)]
                    wt_curve = baselines[s_idx] + amplitudes[s_idx] * P_wt[s_idx]
                    ko_curve = baselines[s_idx] + amplitudes[s_idx] * P_ko[s_idx]

                    fig_ko.add_trace(go.Scatter(x=t_eval, y=wt_curve, mode='lines', line=dict(color=c, width=2),
                                                name=f"{site_name} (WT)", legendgroup=site_name))
                    fig_ko.add_trace(
                        go.Scatter(x=t_eval, y=ko_curve, mode='lines', line=dict(color=c, width=2, dash='dot'),
                                   name=f"{site_name} (KO)", legendgroup=site_name, showlegend=False))

            fig_ko.update_layout(
                title=f"Effect of {target} ({ko_type} KO) on {observe_prot} - {obs_metric}",
                xaxis_title="Time (min)",
                yaxis_title=yaxis_title,
                template="plotly_white",
                height=600
            )
            st.plotly_chart(fig_ko, use_container_width=True)

            # Abundance check
            delta_A = np.mean(A_wt[obs_idx] - A_ko[obs_idx])
            if abs(delta_A) > 0.1:
                st.info(f"Significant change in protein abundance detected for {observe_prot}.")

# ==========================================
# TAB 7: Network Animation
# ==========================================

with tab7:
    st.subheader("Dynamic Network Visualization")
    st.markdown("Visualize the propagation of signals through the kinase-substrate network over time.")

    # --- Controls ---
    c_anim1, c_anim2 = st.columns([1, 3])

    with c_anim1:
        anim_duration = st.slider("Animation Duration (min)", 10, 1000, 120, key="anim_time")

        # NEW: Edge Threshold Slider
        edge_thresh = st.slider("Edge Visibility Threshold",
                                min_value=0.0, max_value=0.1, value=0.001, step=0.001, format="%.4f",
                                help="Lower this if the network looks disconnected.")

        show_crosstalk = st.checkbox("Show Crosstalk Edges?", value=True,
                                     help="Draw interactions between phosphosites (Cg matrix)")

        # Knockout Context
        use_ko_anim = st.checkbox("Apply Knockout?", value=False)
        ko_target_anim = None
        if use_ko_anim:
            ko_target_anim = st.selectbox("KO Target", data["kinases"] + data["proteins"])

        btn_generate_anim = st.button("Generate Animation", type="primary")

    with c_anim2:
        if btn_generate_anim:
            with st.spinner("Building Network Animation..."):

                # 1. Run Simulation (Fine Grid)
                t_anim = np.linspace(0, anim_duration, 40)  # Keep frame count low (~40) for performance
                K, M, N = len(data["proteins"]), len(data["kinases"]), len(data["sites"])
                ModelDims.set_dims(K, M, N)

                # A0 Construction
                A0_anim = np.zeros((K, len(t_anim)), dtype=float)
                if data["A_scaled"].size > 0 and data["A_scaled"].shape[1] > 0:
                    for k, p_idx in enumerate(data["prot_idx_for_A"]):
                        A0_anim[p_idx, 0] = data["A_scaled"][k, 0]

                # Prepare Theta
                theta_anim = data["theta"].copy()
                K_mat_anim = data["K_site_kin"]

                if use_ko_anim and ko_target_anim:
                    # Apply KO logic
                    if ko_target_anim in data["kinases"]:
                        k_idx = data["kinases"].index(ko_target_anim)
                        theta_anim[4 * K + 2 + k_idx] = -20.0
                    elif ko_target_anim in data["proteins"]:
                        p_idx = data["proteins"].index(ko_target_anim)
                        theta_anim[2 * K + p_idx] = -20.0

                # Simulate
                P_anim, A_anim = simulate_p_scipy(
                    t_anim, data["P_scaled"], A0_anim, theta_anim,
                    data["Cg"], data["Cl"], data["site_prot_idx"],
                    K_mat_anim, data["R"], data["L_alpha"], data["kin_to_prot_idx"],
                    data["receptor_mask_prot"], data["receptor_mask_kin"],
                    data["meta"].get("mechanism", "dist")
                )

                # 2. Build Graph (NetworkX)
                G = nx.DiGraph()

                # --- A. ADD NODES ---

                # Add Kinases
                for m, k_name in enumerate(data["kinases"]):
                    prot_idx = data["kin_to_prot_idx"][m]
                    if prot_idx >= 0:
                        activity_trace = A_anim[prot_idx, :]
                    else:
                        activity_trace = np.ones_like(t_anim) * 0.1

                    G.add_node(k_name, size=25, shape="triangle",
                               group="Kinase", color="red",
                               activity=activity_trace.tolist())

                # Add Phosphosites
                for i, s_name in enumerate(data["sites"]):
                    trace = P_anim[i, :]
                    G.add_node(s_name, size=15, shape="circle",
                               group="Phosphosite", color="blue",
                               activity=trace.tolist())

                # --- B. ADD EDGES (With Slider Threshold) ---

                # 1. Kinase -> Site Edges
                rows, cols = np.where(data["K_site_kin"] > edge_thresh)
                for r, c in zip(rows, cols):
                    site_node = data["sites"][r]
                    kin_node = data["kinases"][c]
                    weight = data["K_site_kin"][r, c]
                    G.add_edge(kin_node, site_node, weight=float(weight), color="gray", opacity=0.5)

                # 2. Site <-> Site Crosstalk (Cg)
                if show_crosstalk:
                    # Cg is N x N
                    rows_cg, cols_cg = np.where(data["Cg"] > edge_thresh)
                    for r, c in zip(rows_cg, cols_cg):
                        if r == c: continue  # Skip self loops
                        s1 = data["sites"][r]
                        s2 = data["sites"][c]
                        w = data["Cg"][r, c]
                        # Use a different color for crosstalk (e.g., orange/dashed)
                        G.add_edge(s1, s2, weight=float(w), color="#FFA500", opacity=0.3)

                # 3. Generate Single Graph (Final State)
                # We pick the last time point to show the "result" of the simulation
                t_idx = -1

                Gt = G.copy()

                for node in Gt.nodes():
                    act_list = G.nodes[node]['activity']
                    val = act_list[t_idx]  # Capture the final value only

                    # Normalize visual intensity
                    intensity = int(255 * val)
                    intensity = max(0, min(255, intensity))

                    # Color Logic
                    if Gt.nodes[node]['group'] == 'Kinase':
                        # Bright Red for high activity, Dark Red for low
                        hex_col = f"#{intensity:02x}0000"
                    else:
                        # Bright Green for high phosphorylation, Dark Blue/Black for low
                        # Mixing Blue (low) to Green (high)
                        inv_intensity = 255 - intensity
                        hex_col = f"#00{intensity:02x}{inv_intensity:02x}"

                    Gt.nodes[node]['color'] = hex_col
                    Gt.nodes[node]['label'] = f"{node}\n({val:.2f})"

                    # Optional: Pulse size
                    base_size = G.nodes[node]['size']
                    Gt.nodes[node]['size'] = base_size + (val * 10)

                # Pass as a single-item list so the rest of the code works unchanged
                graphs = [Gt]

                # 4. Render
                if len(G.edges) == 0:
                    st.warning("No edges found! Try lowering the 'Edge Visibility Threshold'.")
                else:
                    st.caption(
                        f"Rendering {len(graphs)} frames with {len(G.nodes)} nodes and {len(G.edges)} edges...")

                    fig = gv.d3(
                        data=graphs,
                        graph_height=650,

                        # --- Visualization Settings ---
                        zoom_factor=0.6,
                        show_menu=True,  # Enables the bottom menu for Play/Pause/Settings
                        show_menu_toggle_button=True,
                        show_details=True,  # Sidebar for node details on click

                        # --- Node & Edge Appearance ---
                        node_label_data_source='label',  # Uses the 'label' attribute we set (Name + Value)
                        node_size_factor=1.0,
                        node_hover_neighborhood=True,  # Highlight connected nodes on hover
                        edge_size_factor=1.0,
                        edge_curvature=0.2,  # Slight curve looks better for complex networks

                        # --- Physics / Layout Algorithm ---
                        layout_algorithm_active=True,

                        # Repulsion (keeps nodes apart)
                        use_many_body_force=True,
                        many_body_force_strength=-150.0,

                        # Links (pulls connected nodes together)
                        use_links_force=True,  # Correct parameter name
                        links_force_distance=150.0,  # Correct parameter name
                        links_force_strength=0.5,

                        # Centering (keeps graph in view)
                        use_centering_force=True
                    )

                    st.components.v1.html(fig.to_html(), height=700)

# ==========================================
# TAB 8: Sensitivity Analysis
# ==========================================
with tab8:
    st.subheader("Global Sensitivity Analysis")
    st.markdown("""
    Explore how variations in model parameters affect the simulation outputs. 
    **Sobol Indices** quantify the contribution of each parameter to the output variance.
    """)

    sens_dir = os.path.join(results_dir, "sensitivity")
    sobol_file = os.path.join(sens_dir, "sobol_indices_labeled.tsv")
    pert_file = os.path.join(sens_dir, "perturbation_data.tsv")

    if not os.path.exists(sens_dir):
        st.warning("Sensitivity analysis results not found. Run the pipeline with `--run-sensitivity`.")
    else:
        # --- SECTION A: Sobol Indices ---
        st.markdown("### 1. Parameter Importance Ranking")

        if os.path.exists(sobol_file):
            df_sobol = pd.read_csv(sobol_file, sep="\t")

            # Filters
            c_sobol1, c_sobol2 = st.columns([1, 3])
            with c_sobol1:
                top_n = st.slider("Show Top N Parameters", 5, 50, 20)
                sort_col = st.radio("Sort By", ["Total_Order", "First_Order"])

            with c_sobol2:
                # Prepare Data
                df_plot = df_sobol.sort_values(sort_col, ascending=False).head(top_n)

                # Bar Plot
                fig_sobol = go.Figure()
                fig_sobol.add_trace(go.Bar(
                    x=df_plot["Parameter"],
                    y=df_plot["Total_Order"],
                    name="Total Effect (ST)",
                    marker_color="skyblue"
                ))
                fig_sobol.add_trace(go.Bar(
                    x=df_plot["Parameter"],
                    y=df_plot["First_Order"],
                    name="First Order (S1)",
                    marker_color="navy",
                    opacity=0.7
                ))

                fig_sobol.update_layout(
                    title=f"Top {top_n} Sensitive Parameters",
                    xaxis_title="Parameter",
                    yaxis_title="Sensitivity Index",
                    barmode="overlay",
                    height=500,
                    template="plotly_white"
                )
                st.plotly_chart(fig_sobol, use_container_width=True)

                with st.expander("View Raw Sobol Indices"):
                    st.dataframe(df_sobol)
        else:
            st.error(f"Sobol indices file missing: {sobol_file}")

        st.divider()

        # --- SECTION B: Perturbation Trajectories ---
        st.markdown("### 2. Output Variance (Perturbation Envelopes)")
        st.markdown("Visualize the spread of trajectories generated by sampling the parameter space.")

        if os.path.exists(pert_file):
            # Optimizing loading for large files
            # We only read columns needed for selection first to be safe,
            # but usually streamlit runs locally so we try loading.
            @st.cache_data
            def load_perturbation_data(path):
                # This file can be huge, use caution
                return pd.read_csv(path, sep="\t")


            try:
                with st.spinner("Loading perturbation data..."):
                    df_pert = load_perturbation_data(pert_file)

                # Selection Controls
                c_pert1, c_pert2, c_pert3 = st.columns(3)
                with c_pert1:
                    avail_types = df_pert["Type"].unique()
                    sel_type = st.selectbox("Entity Type", avail_types, index=0)

                with c_pert2:
                    # Filter entities by type
                    avail_entities = df_pert[df_pert["Type"] == sel_type]["Entity"].unique()
                    sel_entity = st.selectbox("Select Entity", sorted(avail_entities))

                with c_pert3:
                    # Option to show sample limit
                    max_samples = st.slider("Max Samples to Plot", 10, 200, 50, help="Limit lines for performance")

                # Filter Data
                subset = df_pert[
                    (df_pert["Type"] == sel_type) &
                    (df_pert["Entity"] == sel_entity)
                    ]

                # Get unique Sample IDs
                sample_ids = subset["Sample_ID"].unique()
                if len(sample_ids) > max_samples:
                    shown_ids = sample_ids[:max_samples]
                    subset = subset[subset["Sample_ID"].isin(shown_ids)]

                # Plot
                fig_pert = go.Figure()

                # Plot individual lines
                # Group by Sample_ID efficiently
                for sid, grp in subset.groupby("Sample_ID"):
                    fig_pert.add_trace(go.Scatter(
                        x=grp["Time"],
                        y=grp["Value"],
                        mode='lines',
                        line=dict(color='gray', width=1),
                        opacity=0.3,
                        showlegend=False,
                        name=f"Sample {sid}"
                    ))

                # Calculate and plot Mean/Median
                # Pivot to wide format (Time x Sample) for stats
                # Assuming all samples have same time points
                stats_df = subset.groupby("Time")["Value"].agg(["mean", "median", "std"]).reset_index()

                fig_pert.add_trace(go.Scatter(
                    x=stats_df["Time"],
                    y=stats_df["median"],
                    mode='lines',
                    line=dict(color='red', width=3),
                    name="Median Response"
                ))

                # Add Upper/Lower Std Dev Bounds
                fig_pert.add_trace(go.Scatter(
                    x=stats_df["Time"],
                    y=stats_df["mean"] + stats_df["std"],
                    mode='lines',
                    line=dict(width=0),
                    showlegend=False
                ))
                fig_pert.add_trace(go.Scatter(
                    x=stats_df["Time"],
                    y=stats_df["mean"] - stats_df["std"],
                    mode='lines',
                    line=dict(width=0),
                    fill='tonexty',
                    fillcolor='rgba(255, 0, 0, 0.1)',
                    name="Mean Â± 1 SD"
                ))

                fig_pert.update_layout(
                    title=f"Global Sensitivity: Variance in {sel_entity}",
                    xaxis_title="Time (min)",
                    yaxis_title="Simulated Value",
                    template="plotly_white",
                    height=600
                )

                st.plotly_chart(fig_pert, use_container_width=True)

            except Exception as e:
                st.error(f"Error loading/plotting perturbation data: {e}")
                st.info("The file might be too large or malformed.")
        else:
            st.warning(f"Perturbation data file missing: {pert_file}")